import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, GridSearchCV
from xgboost import XGBRegressor
import matplotlib.pyplot as plt

# Power BI automatically imports the dataset as a dataframe named 'dataset'

# Convert the Month names to numerical values
dataset['Month'] = pd.to_datetime(dataset['Month'], format='%B').dt.month

# Create a Date column by combining Year and Month
dataset['Date'] = pd.to_datetime(dataset[['Year', 'Month']].assign(Day=1))

# Sort the data by Date
dataset = dataset.sort_values('Date')

# Aggregate sales by month
monthly_sales = dataset.groupby('Date').agg({'Sales': 'sum'}).reset_index()

# Add lag features (Lag_1 and Lag_2)
monthly_sales['Lag_1'] = monthly_sales['Sales'].shift(1)
monthly_sales['Lag_2'] = monthly_sales['Sales'].shift(2)

# Add rolling window features (3-month rolling mean and std)
monthly_sales['Rolling_Mean_3'] = monthly_sales['Sales'].rolling(window=3).mean().shift(1)
monthly_sales['Rolling_Std_3'] = monthly_sales['Sales'].rolling(window=3).std().shift(1)

# Add cyclical features (sin and cos transformation of Month_Num)
monthly_sales['Month_Num'] = np.arange(len(monthly_sales))
monthly_sales['Month_Sin'] = np.sin(2 * np.pi * monthly_sales['Month_Num'] / 12)
monthly_sales['Month_Cos'] = np.cos(2 * np.pi * monthly_sales['Month_Num'] / 12)

# Drop rows with NaN values generated by lag and rolling operations
monthly_sales = monthly_sales.dropna()

# Prepare the feature and target variables
X = monthly_sales[['Month_Sin', 'Month_Cos', 'Lag_1', 'Lag_2', 'Rolling_Mean_3', 'Rolling_Std_3']]
y = monthly_sales['Sales']

# Split the data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Define parameter grid for GridSearchCV
param_grid = {
    'n_estimators': [50, 100, 200],
    'max_depth': [3, 5, 7],
    'learning_rate': [0.01, 0.1, 0.3]
}

# Perform GridSearchCV to find the best model
grid_search = GridSearchCV(XGBRegressor(random_state=42), param_grid, cv=5, scoring='neg_mean_squared_error')
grid_search.fit(X_train, y_train)

# Get the best model from grid search
best_model = grid_search.best_estimator_

# Generate predictions for the actual data
monthly_sales['Predicted_Sales'] = best_model.predict(X)

# Extend the forecast to the next 6 months
future_months = np.arange(len(monthly_sales), len(monthly_sales) + 6).reshape(-1, 1)

# To predict future values, we need to create corresponding features for future dates
last_sales_values = monthly_sales[['Sales']].tail(2).values.flatten()
last_mean_value = monthly_sales['Rolling_Mean_3'].iloc[-1]
last_std_value = monthly_sales['Rolling_Std_3'].iloc[-1]
future_sales = []
for i in range(6):
    lag_1 = last_sales_values[-1] if i == 0 else future_sales[-1]
    lag_2 = last_sales_values[-2] if i < 2 else future_sales[-2]
    future_month_num = future_months[i][0]
    month_sin = np.sin(2 * np.pi * future_month_num / 12)
    month_cos = np.cos(2 * np.pi * future_month_num / 12)
    future_X = np.array([[month_sin, month_cos, lag_1, lag_2, last_mean_value, last_std_value]])
    predicted_value = best_model.predict(future_X)[0]
    future_sales.append(predicted_value)
    last_sales_values = np.append(last_sales_values, predicted_value)

# Create future dates for the forecast
last_date = monthly_sales['Date'].max()
future_dates = pd.date_range(last_date, periods=7, freq='M')[1:]

# Create a DataFrame for future predictions
future_df = pd.DataFrame({
    'Date': future_dates,
    'Predicted_Sales': future_sales
})

# Combine actual data with future predictions
combined_df = pd.concat([monthly_sales[['Date', 'Sales', 'Predicted_Sales']], future_df], ignore_index=True)

# Adjust the combined data to ensure no actual sales data appears in the forecast period
combined_df.loc[combined_df['Date'] > last_date, 'Sales'] = np.nan

# Plot the results
plt.figure(figsize=(12, 6))

# Plot actual sales with markers for clarity
plt.plot(combined_df['Date'], combined_df['Sales'], label='Actual Sales', color='blue', marker='o')

# Plot fitted/forecasted sales with a different line style and color
plt.plot(combined_df['Date'], combined_df['Predicted_Sales'], label='Fitted/Forecasted Sales', linestyle='--', color='red')

plt.xticks(rotation=45)
plt.xlabel('Date')
plt.ylabel('Sales')
plt.title('Sales Forecasting - XGBoost Regression with Advanced Features')
plt.legend()
plt.tight_layout()
plt.show()
